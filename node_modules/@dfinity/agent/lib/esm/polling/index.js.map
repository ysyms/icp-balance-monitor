{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/polling/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { Agent, Expiry, RequestStatusResponseStatus } from '../agent';\nimport { Certificate, CreateCertificateOptions, lookupResultToBuffer } from '../certificate';\nimport { RequestId } from '../request_id';\nimport { toHex } from '../utils/buffer';\n\nexport * as strategy from './strategy';\nimport { defaultStrategy } from './strategy';\nimport { DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS } from '../constants';\nimport { ReadRequestType, ReadStateRequest } from '../agent/http/types';\nexport { defaultStrategy } from './strategy';\nexport type PollStrategy = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<void>;\nexport type PollStrategyFactory = () => PollStrategy;\n\ninterface SignedReadStateRequestWithExpiry {\n  body: {\n    content: Pick<ReadStateRequest, 'request_type' | 'ingress_expiry'>;\n  };\n}\n\n/**\n * Check if an object has a property\n * @param value the object that might have the property\n * @param property the key of property we're looking for\n */\nfunction hasProperty<O extends object, P extends string>(\n  value: O,\n  property: P,\n): value is O & Record<P, unknown> {\n  return Object.prototype.hasOwnProperty.call(value, property);\n}\n\n/**\n * Check if value is a signed read state request with expiry\n * @param value to check\n */\nfunction isSignedReadStateRequestWithExpiry(\n  value: unknown,\n): value is SignedReadStateRequestWithExpiry {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    hasProperty(value, 'body') &&\n    value.body !== null &&\n    typeof value.body === 'object' &&\n    hasProperty(value.body, 'content') &&\n    value.body.content !== null &&\n    typeof value.body.content === 'object' &&\n    hasProperty(value.body.content, 'request_type') &&\n    value.body.content.request_type === ReadRequestType.ReadState &&\n    hasProperty(value.body.content, 'ingress_expiry') &&\n    typeof value.body.content.ingress_expiry === 'object' &&\n    value.body.content.ingress_expiry !== null &&\n    hasProperty(value.body.content.ingress_expiry, 'toCBOR') &&\n    typeof value.body.content.ingress_expiry.toCBOR === 'function' &&\n    hasProperty(value.body.content.ingress_expiry, 'toHash') &&\n    typeof value.body.content.ingress_expiry.toHash === 'function'\n  );\n}\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the repeated readState call.\n * @param blsVerify - optional replacement function that verifies the BLS signature of a certificate.\n */\nexport async function pollForResponse(\n  agent: Agent,\n  canisterId: Principal,\n  requestId: RequestId,\n  strategy: PollStrategy = defaultStrategy(),\n  request?: unknown,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): Promise<{\n  certificate: Certificate;\n  reply: ArrayBuffer;\n}> {\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const currentRequest = request ?? (await agent.createReadStateRequest?.({ paths: [path] }));\n\n  const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n  if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify,\n  });\n\n  const maybeBuf = lookupResultToBuffer(cert.lookup([...path, new TextEncoder().encode('status')]));\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied: {\n      return {\n        reply: lookupResultToBuffer(cert.lookup([...path, 'reply']))!,\n        certificate: cert,\n      };\n    }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest, blsVerify);\n\n    case RequestStatusResponseStatus.Rejected: {\n      const rejectCode = new Uint8Array(\n        lookupResultToBuffer(cert.lookup([...path, 'reject_code']))!,\n      )[0];\n      const rejectMessage = new TextDecoder().decode(\n        lookupResultToBuffer(cert.lookup([...path, 'reject_message']))!,\n      );\n      throw new Error(\n        `Call was rejected:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Reject code: ${rejectCode}\\n` +\n          `  Reject text: ${rejectMessage}\\n`,\n      );\n    }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(\n        `Call was marked as done but we never saw the reply:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n`,\n      );\n  }\n  throw new Error('unreachable');\n}\n"]}